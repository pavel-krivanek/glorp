"
This is a an abstract superclass for the protocol 2 and protocol 3 APIs of the open-source PostgreSQL database.

This supports binding but has it off by default.  To change this generally, implement (class-side) useBindingByDefault to return true for it or a subclass.  To change it (for all platforms) in a given image, set
	Glorp.DatabasePlatform.UseBindingIfSupported := true
In either case check already-assigned values of any existing platform instances after changing.

Instance Variables
	charactersThatNeedEscaping	<Array of Char>	the standard_conforming_strings setting determines whether we must escape backslash;  we must always escape single-quote
"
Class {
	#name : #PostgresPlatform,
	#superclass : #DatabasePlatform,
	#instVars : [
		'charactersThatNeedEscaping'
	],
	#category : #'Glorp-Database'
}

{ #category : #constants }
PostgresPlatform class >> reservedWords [
	^#('all' 'analyse' 'analyze' 'and' 'any' 'array' 'as' 'asc' 'asymmetric' 'both' 'case' 'cast' 'check' 'collate' 'column' 'constraint' 'create' 'current_catalog' 'current_date' 'current_role' 'current_time' 'current_timestamp' 'current_user' 'default' 'deferrable' 'desc' 'distinct' 'do' 'else' 'end' 'except' 'false' 'fetch' 'for' 'foreign' 'from' 'grant' 'group' 'having' 'in' 'initially' 'intersect' 'into' 'leading' 'limit' 'localtime' 'localtimestamp' 'not' 'null' 'offset' 'on' 'only' 'or' 'order' 'placing' 'primary' 'references' 'returning' 'select' 'session_user' 'some' 'symmetric' 'table' 'then' 'to' 'trailing' 'true' 'union' 'unique' 'user' 'using' 'variadic' 'when' 'where' 'window' 'with')
		asSet
]

{ #category : #testing }
PostgresPlatform class >> useBindingByDefault [
	^false
]

{ #category : #constants }
PostgresPlatform >> areSequencesExplicitlyCreated [
	^true.
]

{ #category : #types }
PostgresPlatform >> bigint [
	^self typeNamed: #bigint ifAbsentPut: [GlorpIntegerType new typeString: 'bigint'].
]

{ #category : #binding }
PostgresPlatform >> bindingsForGroupWritingFor: aCommand [
	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."
	^aCommand batchStatementBindings.
]

{ #category : #types }
PostgresPlatform >> blob [

	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'bytea'].
]

{ #category : #types }
PostgresPlatform >> boolean [
	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'boolean'].
]

{ #category : #'conversion-strings' }
PostgresPlatform >> byteArrayToSQLStringConverter [

	^DelegatingDatabaseConverter
		named: #byteArrayToSQLString
		hostedBy: self
		fromStToDb: #convertByteArrayToSQLString:for:
		fromDbToSt: #convertSQLStringToByteArray:for:.
]

{ #category : #types }
PostgresPlatform >> char [
	^self typeNamed: #char ifAbsentPut: [GlorpCharType new typeName: 'character'].
]

{ #category : #constants }
PostgresPlatform >> charactersThatNeedEscaping [
	"We use the instvar's being set as a guard for all postInitialize values being set, so never set it alone.  The ifNil: value is a string containing a single quote."

	^charactersThatNeedEscaping ifNil: ['''']
]

{ #category : #constants }
PostgresPlatform >> charactersThatNeedEscaping: aCollectionOfChars [
	"Call this if you know the database servers setting for standard-conforming_strings and so can save the postLoginInitializeFrom: call."

	charactersThatNeedEscaping := aCollectionOfChars
]

{ #category : #types }
PostgresPlatform >> clob [

	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'text'].
]

{ #category : #'conversion-strings' }
PostgresPlatform >> convertSQLStringToByteArray: aString for: aType [

	| aStream str | 
	aString isNil ifTrue: [^nil].
	aStream := (ByteArray new: aString size // 4) writeStream.
	str := aString readStream.
	[str atEnd] whileFalse: [ |nextChar|
		nextChar := str next.
		aStream nextPut: (nextChar = $\
								ifTrue: [str peek = $\
											ifTrue: [str next asInteger]
											ifFalse: [Number readFrom: (str next: 3) base: 8]]
								ifFalse: [nextChar asInteger])
	].
	aStream close.
	^aStream contents
]

{ #category : #sequences }
PostgresPlatform >> databaseSequenceClass [
	^PGSequence.
]

{ #category : #types }
PostgresPlatform >> date [
	^self typeNamed: #date ifAbsentPut: [GlorpDateType new typeString: 'date'].
]

{ #category : #types }
PostgresPlatform >> decimal [
	^self numeric.
]

{ #category : #types }
PostgresPlatform >> double [
	^self float8
]

{ #category : #'conversion-strings' }
PostgresPlatform >> encodeAsBase64String: aByteArray [
	"Pure inline of Base64FastCoder's method."

	| output thirdTripletIndex firstQuartetIndex firstOfThree secondOfThree thirdOfThree remainder |
	output := ByteString new: (aByteArray size / 3) ceiling * 4.
	thirdTripletIndex := 3.
	firstQuartetIndex := 1.	"Process all complete triplets."
	[thirdTripletIndex > aByteArray size] whileFalse: 
			[firstOfThree := aByteArray at: thirdTripletIndex - 2.
			secondOfThree := aByteArray at: thirdTripletIndex - 1.
			thirdOfThree := aByteArray at: thirdTripletIndex.
			output at: firstQuartetIndex
				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
						at: ((firstOfThree bitAnd: 2r11111100) bitShift: -2) + 1).
			output at: firstQuartetIndex + 1
				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
						at: (((firstOfThree bitAnd: 2r00000011) bitShift: 4)
								bitOr: ((secondOfThree bitAnd: 2r11110000) bitShift: -4)) + 1).
			output at: firstQuartetIndex + 2
				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
						at: (((secondOfThree bitAnd: 2r00001111) bitShift: 2)
								bitOr: ((thirdOfThree bitAnd: 2r11000000) bitShift: -6)) + 1).
			output at: firstQuartetIndex + 3
				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
						at: (thirdOfThree bitAnd: 2r00111111) + 1).
			thirdTripletIndex := thirdTripletIndex + 3.
			firstQuartetIndex := firstQuartetIndex + 4].	"Process any final incomplete triplet."
	remainder := thirdTripletIndex - aByteArray size.
	remainder = 3 ifTrue: [^output].
	firstOfThree := aByteArray at: thirdTripletIndex - 2.
	output at: firstQuartetIndex
		put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
				at: ((firstOfThree bitAnd: 2r11111100) bitShift: -2) + 1).
	output at: firstQuartetIndex + 3 put: $=.
	remainder = 1
		ifFalse: 
			["the byte array is missing two values of another triplet"
			output at: firstQuartetIndex + 1
				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
						at: ((firstOfThree bitAnd: 2r00000011) bitShift: 4) + 1).
			output at: firstQuartetIndex + 2 put: $=]
		ifTrue: 
			["the byte array is only missing one value of another triplet"
			secondOfThree := aByteArray at: thirdTripletIndex - 1.
			output at: firstQuartetIndex + 1
				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
						at: (((firstOfThree bitAnd: 2r00000011) bitShift: 4)
								bitOr: ((secondOfThree bitAnd: 2r11110000) bitShift: -4)) + 1).
			output at: firstQuartetIndex + 2
				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
						at: ((secondOfThree bitAnd: 2r00001111) bitShift: 2) + 1)].
	^output
]

{ #category : #types }
PostgresPlatform >> float [
	^self float4.
]

{ #category : #types }
PostgresPlatform >> float4 [
	^self typeNamed: #float4 ifAbsentPut: [GlorpFloatType new].
]

{ #category : #types }
PostgresPlatform >> float8 [
	^self typeNamed: #float8 ifAbsentPut: [GlorpDoubleType new].
]

{ #category : #functions }
PostgresPlatform >> initializeFunctions [
	"Postgres supports standard regex and also the ANSI SQL 'SIMILAR TO' form of regex, in which the % and _ of SQL's LIKE predicate replace the corresponding * and ? of regex."

	super initializeFunctions.
	functions at: #similarTo: put: (InfixFunction named: 'SIMILAR TO').
	functions at: #regexMatches: put: (InfixFunction named: '~').
]

{ #category : #constants }
PostgresPlatform >> initializeReservedWords [
	super initializeReservedWords.
]

{ #category : #types }
PostgresPlatform >> int [
	^self int4
]

{ #category : #types }
PostgresPlatform >> int2 [
	^self typeNamed: #int2 ifAbsentPut: [GlorpIntegerType new typeString: 'int2'].
]

{ #category : #types }
PostgresPlatform >> int4 [
	^self typeNamed: #int4 ifAbsentPut: [GlorpIntegerType new typeString: 'int4'].
]

{ #category : #types }
PostgresPlatform >> int8 [
	^self typeNamed: #int8 ifAbsentPut: [GlorpIntegerType new typeString: 'int8'].
]

{ #category : #testing }
PostgresPlatform >> isPostgreSQLPlatform [
	^true.
]

{ #category : #constants }
PostgresPlatform >> maximumLengthOfColumnName [
	"^<Integer> I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"

	^31
]

{ #category : #constants }
PostgresPlatform >> maximumLengthOfTableName [
	"^<Integer> I return the max. length of a table name"

	^31
]

{ #category : #testing }
PostgresPlatform >> measuresStringFieldWidthsInBytes [
	"Return true if we measure the width of a string in bytes rather than characters. So, a 255-character field can hold 255 bytes worth of string, not 255 characters. This is important with encodings"
	^true.
]

{ #category : #types }
PostgresPlatform >> numeric [
	^self typeNamed: #numeric ifAbsentPut: [GlorpNumericType new].
]

{ #category : #'conversion-strings' }
PostgresPlatform >> postLoginInitializeFromAccessor: aDatabaseAccessor [
	"If we cannot get the standard_conforming_strings state, assume the database is too old to understand it."

	| standardConformingStrings |
	charactersThatNeedEscaping isNil ifFalse: [^self].
	standardConformingStrings :=
		[aDatabaseAccessor executeSQLString: 'SHOW standard_conforming_strings']
			on: Dialect error
			do: [:ex |
				(ex description indexOfSubCollection: 'standard_conforming_strings' startingAt: 1) = 0
					ifFalse: [#(('off'))]
					ifTrue: [ex pass]].
	standardConformingStrings = #(('on'))
		ifTrue: [charactersThatNeedEscaping := '''']	"escape single quote characters only"
		ifFalse: [charactersThatNeedEscaping := '''\'].	"escape single quote and backslash"
]

{ #category : #'conversion-strings' }
PostgresPlatform >> printBlob: aByteArray on: aStream for: aType [
	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].
	Dialect isSqueak ifTrue: [^self squeakPrintBlob: aByteArray on: aStream for: aType].
	aStream nextPutAll: (self encodeAsBase64String: aByteArray) printString
]

{ #category : #'conversion-times' }
PostgresPlatform >> printDate: aDate for: aType [
	"Print a date (or timestamp) as yyyy-mm-dd"
	| stream |
	aDate isNil ifTrue: [^'NULL'].
	stream := WriteStream on: String new.
	stream nextPut: $'.
	self
		printDate: aDate
		isoFormatOn: stream.
	stream nextPut: $'.
	^stream contents.
]

{ #category : #'database-specific' }
PostgresPlatform >> printOffset: anInteger on: aCommand [
	aCommand
		nextPutAll: ' OFFSET '.
	anInteger printOn: aCommand.
]

{ #category : #'database-specific' }
PostgresPlatform >> printPostLimit: anInteger on: aCommand [
	aCommand
		nextPutAll: ' LIMIT '.
	anInteger printOn: aCommand.
]

{ #category : #'conversion-times' }
PostgresPlatform >> printTime: aTime for: aType [
	"Print a time (or timestamp) as hh:mm:ss.fff"
	| stream |
	aTime isNil ifTrue: [^'NULL'].
	stream := WriteStream on: String new.
	stream nextPut: $'.
	self
		printTime: aTime
		isoFormatOn: stream.
	stream nextPut: $'.
	^stream contents.
]

{ #category : #'conversion-times' }
PostgresPlatform >> printTimestamp: aTimestamp on: stream for: aType [
	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].
	stream nextPut: $'.
	self
		printDate: aTimestamp
		isoFormatOn: stream.
	stream nextPutAll: ' '.
	self
		printTime: aTimestamp
		isoFormatOn: stream.
	stream nextPut: $'.
]

{ #category : #types }
PostgresPlatform >> real [
	^self float4
]

{ #category : #testing }
PostgresPlatform >> requiresCastsForNullsInUnions [
	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."
	^true.
]

{ #category : #constants }
PostgresPlatform >> requiresTransactionForTableOperations [
	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"
	^false.
]

{ #category : #types }
PostgresPlatform >> sequence [

	^self serial
]

{ #category : #types }
PostgresPlatform >> serial [
	"For postgresql, we use sequences, and explicitly get the values ourselves, so just tell the database that they're integers."
	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'integer'].
]

{ #category : #types }
PostgresPlatform >> smallint [
	^self int2
]

{ #category : #constants }
PostgresPlatform >> sqlTextCurrentServerUTCTimestamp [

	^'SELECT CURRENT_TIMESTAMP AT TIME ZONE ''UTC'' '
]

{ #category : #'conversion-strings' }
PostgresPlatform >> squeakPrintBlob: aByteArray on: aStream for: aType [

	aStream nextPut: $'.
	aByteArray do: [:each |
		aStream nextPutAll: '\\'.
		each asInteger printOn: aStream paddedWith: $0 to: 3 base: 8].
	aStream nextPutAll: '''::bytea'.
]

{ #category : #testing }
PostgresPlatform >> supportsANSIJoins [
	"Do we support the JOIN <tableName> USING <criteria> syntax."
	^true.
]

{ #category : #testing }
PostgresPlatform >> supportsBinding [
	"Binding works only with VW EXDI so far"
	^Dialect isVisualWorks.
]

{ #category : #testing }
PostgresPlatform >> supportsCaseInsensitiveLike [
	^true.
]

{ #category : #testing }
PostgresPlatform >> supportsCompositeKeyArgsForOperand: aSymbol [
	"Strictly, the answer is
		^#(#= #IN #<>) includes: aSymbol
but we take it for granted that we are never called on aSymbol that is not one of these values;  see the guard in #rewriteEquality.."

	^true
]

{ #category : #testing }
PostgresPlatform >> supportsGroupWritingFor: aCommand [
	"The 2.0 driver never supported binding but only pretended that it did to the upper-level EXDI API, reinserting the bound values as strings into an SQL stream that it then sent unbound to the server.  Thus it can inherit this unaltered.  The 3.0 drivers can group statements unbound.  If the serverVersion is 8.2 or newer, they can also group values in a single insert statement and they can do this unbound or bound."

	^aCommand supportsGroupWriting
]

{ #category : #testing }
PostgresPlatform >> supportsLimit [
	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"
	^true.
]

{ #category : #constants }
PostgresPlatform >> supportsMillisecondsInTimes [
	"I think this depends on settings, but it's easier right now to just turn it off"
	^false.
]

{ #category : #testing }
PostgresPlatform >> supportsOffset [
	"Do we support anything analogous to the postgresql OFFSET, skipping the first N rows"
	^true.
]

{ #category : #testing }
PostgresPlatform >> supportsStringQueryOnBlobs [
	"If we are bound, the bytea = text comparison is illegal."

	^self useBinding not
]

{ #category : #'services tables' }
PostgresPlatform >> tableNameFor: aStringRepresentingATableName [
	"Return the table name, as modified to be used in a database statement."
	
	^(aStringRepresentingATableName
		detect: [:each | each isUppercase]
		ifNone: [nil]) isNil
	ifTrue: [aStringRepresentingATableName]
	ifFalse: ['"' , aStringRepresentingATableName , '"'].
]

{ #category : #types }
PostgresPlatform >> time [
	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time'].
]

{ #category : #types }
PostgresPlatform >> timeStampTypeString [
	^'timestamp'.
]

{ #category : #types }
PostgresPlatform >> timestamp [
	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'timestamp without time zone'].
]

{ #category : #types }
PostgresPlatform >> timestamptz [
	^self typeNamed: #timestamptz ifAbsentPut: [GlorpPGTimestampWithTimeZoneType new]
]

{ #category : #types }
PostgresPlatform >> timetz [
	^self typeNamed: #timetz ifAbsentPut: [GlorpPGTimeWithTimeZoneType new].
]

{ #category : #'type helpers' }
PostgresPlatform >> typesWithValues [
	super typesWithValues.
	self boolean.
	self bigint.
	self date.
	self decimal.
	self double.
	self float.
	self float4.
	self float8.
	self int2.
	self int.
	self integer.
	self numeric.
	self real.
	self sequence.
	self serial.
	self timetz.
	self timestamptz.
	^self types.
]

{ #category : #testing }
PostgresPlatform >> usesArrayBindingRatherThanGroupWriting [
	"Return true if we use array binding for grouped writes rather than printing the sql multiple times. Only applies if we support grouped writes"
	^false.
]

{ #category : #testing }
PostgresPlatform >> usesInformationSchema [

	^true
]

{ #category : #testing }
PostgresPlatform >> usesLengthNotEndPosInSubstring [
	^true
]

{ #category : #types }
PostgresPlatform >> varchar [
	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new typeName: 'character varying'].
]

{ #category : #'database-specific' }
PostgresPlatform >> withRecursive [
	"Return the platform specific version of a common table expression that will recurse."

	^'WITH RECURSIVE'
]
