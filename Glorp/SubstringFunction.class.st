"
This is a function subclass specifically for substring functions. It needs its own separate subclass because it has to be written out differently for different databases, particularly if applied to LOB types.
"
Class {
	#name : #SubstringFunction,
	#superclass : #PrefixFunction,
	#category : #'Glorp-Exceptions'
}

{ #category : #preparing }
SubstringFunction >> _rewriteFunctionArguments [
	"SUBSTR wants arguments position and length rather than (start) position and end position in Postgres, Oracle (not OracleODBC), MySQL, SQL Server and DB2."

	Halt now.
	base ultimateBaseExpression system platform usesLengthNotEndPosInSubstring
		ifTrue: [arguments last value: arguments last value - arguments first value + 1].
]

{ #category : #printing }
SubstringFunction >> printBasicSQLOn: aStream withParameters: aDictionary forSelect: aBoolean [

	^self ultimateBaseExpression system platform isPostgreSQLPlatform
		ifFalse: [ super printBasicSQLOn: aStream withParameters: aDictionary forSelect: aBoolean ]
		ifTrue: [
	aStream
		nextPutAll: function;
		nextPut: $(.
	aBoolean
		ifTrue: [base printSelectSQLOn: aStream withParameters: aDictionary]
		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].
	aStream nextPutAll: ' from '.
	aBoolean 
		ifTrue: [ (arguments at: 1) printSelectSQLOn: aStream withParameters: aDictionary]
		ifFalse: [ (arguments at: 1) printSQLOn: aStream withParameters: aDictionary].
	aStream nextPutAll: ' for '.
	aBoolean 
		ifTrue: [ (arguments at: 2) printSelectSQLOn: aStream withParameters: aDictionary]
		ifFalse: [ (arguments at: 2) printSQLOn: aStream withParameters: aDictionary].
	aStream nextPut: $).
	alias notNil
		ifTrue:
			[aStream
				nextPutAll: ' AS ';
				nextPutAll: alias]].
]

{ #category : #rewriting }
SubstringFunction >> rewriteForOracleBlobsWith: mainArgument [
	"For Oracle blobs, we can't query with a normal substring function, but rather have to use the DBMS_LOB function, whose arguments are backwards. Further, we don't seem to be able to compare to byte-arrays, so turn it into a string."
	| oldBase template startPosition length |
	(mainArgument isGlorpExpression and: [mainArgument isConstantExpression]) ifFalse: [^self].
	function := 'UTL_RAW.CAST_TO_VARCHAR2'.
	startPosition := arguments first value.
	arguments last value.
	length := arguments last value.
	arguments := #().
	oldBase := base.
	template := PrefixFunction named: 'DBMS_LOB.SUBSTR'.
	base := template createFor: (Array with: length asGlorpExpression with: startPosition asGlorpExpression) withBase: oldBase symbol: #dbmsLobSubstr.
]

{ #category : #rewriting }
SubstringFunction >> rewriteForPostgresqlBase64BlobsWith: mainArgument [
	"This is pretty awful. We expect our main argument to be a string, and we're a substring function, but we know that for some types, the string representation comes out differently in the database. In particular, the Postgresql driver stores strings into lobs in Base64. So, if our previous argument = the string size, rewrite it to the database size. This makes it work if we do
    (someObject blob copyFrom: 1 to: 3) = 'abc'
when in fact, the length of that string in the blob will be 4."
	| stream actualArgument base64Length base64Start |
	(mainArgument isGlorpExpression and: [mainArgument isConstantExpression]) ifFalse: [^self].
	self field type = self field platform blob ifFalse: [^self].
	(mainArgument value size \\ 3) = 0 ifFalse: [self error: 'Sorry, but you will need to use a number of characters that base64 encodes exactly'].
	base64Length := (mainArgument value size // 3) * 4.
	arguments at: 2 put: base64Length asGlorpExpression.
	base64Start := ((arguments first value // 3) * 4) + 1.
	arguments at: 1 put: base64Start asGlorpExpression.
	stream := WriteStream on: String new.
	self field type print: mainArgument value on: stream.
	actualArgument := (ReadStream on: stream contents) skip: 1; upTo: $'.
	mainArgument value: actualArgument.
]

{ #category : #preparing }
SubstringFunction >> rewriteFunctionArguments [
	"SUBSTR wants arguments position and length rather than (start) position and end position in Postgres, Oracle (not OracleODBC), MySQL, SQL Server and DB2.  If the arguments are all constants, we just compute the new last argument's value.  If not, we generate an expression for it.  Ideally, we would then symbolically evaluate this expression to null out same-value terms, e.g. by converting
	LENGTH(...) - (LENGTH(...) - 2 + 1)
into
	0 - (0 - 2) + 1
so the we could evaluate it, as for constants.  For now, we leave this and just send the whole thing to the database to evaluate."

	| rewrittenExpression |
	base ultimateBaseExpression system platform usesLengthNotEndPosInSubstring ifFalse: [^self].	"Nothing to do"
	(arguments allSatisfy: [:each | each isConstantExpression]) ifTrue:	"set value of last constant to length (from endPosition)"
		[^arguments last value: arguments last value - arguments first value + 1].
	"Not all constants, so compute an expression for last - first ..."
	rewrittenExpression := RelationExpression
		named: #-
		basedOn: arguments last
		withArguments: (Array with: arguments first).
	" ... + 1"
	rewrittenExpression leftChild isConstantExpression
		ifTrue: [rewrittenExpression leftChild value: rewrittenExpression leftChild value + 1]
		ifFalse: [rewrittenExpression rightChild isConstantExpression
				ifTrue: [rewrittenExpression rightChild value: rewrittenExpression rightChild value - 1]
				ifFalse: [rewrittenExpression := RelationExpression
						named: #+
						basedOn: rewrittenExpression
						withArguments: (Array with: 1)]].
	arguments at: arguments size put: rewrittenExpression.
]

{ #category : #rewriting }
SubstringFunction >> rewriteFunctionArgumentsWith: mainArgument [
	"This is pretty awful. We expect our main argument to be a string, and we're a substring function, but we know that for some types, the string representation comes out differently in the database. In particular, the Postgresql driver stores strings into lobs in Base64. So, if our previous argument = the string size, rewrite it to the database size. This makes it work if we do
    (someObject blob copyFrom: 1 to: 3) = 'abc'
when in fact, the length of that string in the blob will be 4."

	| platform |
	platform := base ultimateBaseExpression system platform.
	(platform isPostgreSQLPlatform and: [self field type = platform blob]) ifTrue: [^self rewriteForPostgresqlBase64BlobsWith: mainArgument].
	(platform isOraclePlatform and: [self field type = platform blob]) ifTrue: [^self rewriteForOracleBlobsWith: mainArgument].
]

{ #category : #accessing }
SubstringFunction >> type [

	| aPlatform |
	^(aPlatform := self ultimateBaseExpression system platform) isDB2Platform
		ifTrue: [super type]
		ifFalse: [aPlatform varchar: 255]
]
