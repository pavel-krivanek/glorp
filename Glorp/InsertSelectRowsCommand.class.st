"
I allow insertion of multiple rows in a single round trip when the target table has an IdentityColumn.  I insert rows and then select the values generated by the server for the identity column in the inserted rows.  These values are output into a temporary table variable declared before the insert.  The three statements that make up this command's SQL are, for example,

	DECLARE @TableOfIdentities TABLE (IdentValue INT);
	INSERT INTO mytable(firstname, lastname, address)
		OUTPUT Inserted.id INTO @TableOfIdentities(IdentValue)
		VALUES (?, ?, ?);
	SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue

when bound, or

	DECLARE @TableOfIdentities TABLE (IdentValue INT);
	INSERT INTO mytable(firstname, lastname, address)
		OUTPUT Inserted.id INTO @TableOfIdentities(IdentValue)
		VALUES  ( 'James', 'Bond', '10 Richmond Place'), ('Sherlock', 'Holmes', '221b Baker Street'), ('Jane', 'Marple', 'St Mary's Mead') ...;
	SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue

when unbound.
"
Class {
	#name : #InsertSelectRowsCommand,
	#superclass : #InsertSelectRowCommand,
	#category : #'Glorp-Database'
}

{ #category : #executing }
InsertSelectRowsCommand >> allRowsGrouped: maxSizeInteger evaluate: aBlock [
	"An ad-hoc mapping can create a situation in which the identity column value that the server will assign to one row is transformed into another value in another row in this same batch of rows.  Rather than try to compute which batches can be safely run in which order, we immediately give up and revert to running each row singly.  The typical case is an array of chained blobs; see the calling chain above and below #blobToDatabaseForRows:nextBlob:nextBlobRows: for an example."

	self identityColumnValueReusedInLaterRow
		ifTrue: [self allRowsSinglyEvaluate: aBlock]
		ifFalse: [super allRowsGrouped: maxSizeInteger evaluate: aBlock].
]

{ #category : #executing }
InsertSelectRowsCommand >> allRowsSinglyEvaluate: aBlock [
	"Run each row singly."

	| theRows |
	theRows := allRows.
	allRows := nil.
	theRows do:
		[:each |
		self row: each.
		allRows := Array with: each.
		aBlock value].
	"We're finished;  reset me back to my start state."
	allRows := theRows.
	self row: allRows first.
]

{ #category : #accessing }
InsertSelectRowsCommand >> arrayBoundFields [
	"For the special case where our array has only one row, use singleRowBoundFields."

	^self shouldUseGroupWriting
		ifTrue: [super arrayBoundFields]
		ifFalse: [self singleRowBoundFields]
]

{ #category : #'private-accessing' }
InsertSelectRowsCommand >> declareTableOfIdentitiesStatement [
	"There is a technique offered for SQL Server array inserts to tables with an identity column.
	The automatically inserted identity values are returned to Glorp for updating the row values.
	The technique uses three separate but related queries, with the second one resembling the usual
	insert statement (with an OUTPUT clause imposed). Here's a typical example:
		INSERT INTO dbo.TAX (NAME,TYPE,TAX_ID) VALUES (?,?,?)
	becomes:
		'DECLARE @TableOfIdentities TABLE (IdentValue INT);
		INSERT INTO dbo.TAX (NAME,TYPE,TAX_ID) OUTPUT Inserted.ID INTO @TableOfIdentities(IdentValue)  VALUES (?,?,?);
		SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue'
	This method returns the first line above."

	^'DECLARE @TableOfIdentities TABLE (IdentValue INT); '
]

{ #category : #testing }
InsertSelectRowsCommand >> identityColumnValueReusedInLaterRow [
	"Do I have a server-assigned id that will be reused in another row in this batch.  If so, it may be unsafe to group the values."

	allRows do:
		[:each || sameTableContainers | sameTableContainers := false.
		(each wrapperAt: identityColumn) containedBy keysAndValuesDo:
			[:eachKey :eachValue |
			sameTableContainers ifTrue: [^true].	"two rows use this value;  unsafe to group"
			eachKey table = each table ifTrue: [sameTableContainers := true]]].
	^false
]

{ #category : #'private-accessing' }
InsertSelectRowsCommand >> outputAddedIdentityColumnValuesIntoTable: idFieldName [
	"This addition to the INSERT statement puts the server-added ids into a table (see #declareTableOfIdentitiesStatement)."

	^'  OUTPUT Inserted.', idFieldName name, ' INTO @TableOfIdentities(IdentValue)'
]

{ #category : #executing }
InsertSelectRowsCommand >> postWriteAssignSequenceInRoundTrip: result [
	"Capture the IDs generated by SQL Server for the IDENTITY column.  For reasons unknown, SQL Server unbound returns all the IDs in a single answer stream, whereas bound returns them in separate answer streams, one for each inserted row."

	useBinding
		ifTrue:
			[allRows do:
				[:ithrow |
				ithrow
					at: identityColumn
					put: (result upToEndOfResultSet first atIndex: 1)]]
		ifFalse:
			[allRows with: result upToEnd do:
				[:ithrow :ithid |
				ithrow
					at: identityColumn
					put: (ithid atIndex: 1)]].
]

{ #category : #executing }
InsertSelectRowsCommand >> printSQL [
	"Declare a pseudo-table with column to hold the server-generated identity column values, so we can select them."

	self nextPutAll: self declareTableOfIdentitiesStatement.
	super printSQL.
]

{ #category : #executing }
InsertSelectRowsCommand >> printSQLForFirstRow: aRow [
	"The same SQL as the super call except with insertion of OUTPUT of the server-generated identity column ids to the declared table () ."

	| fields |
	self nextPutAll: 'INSERT INTO '.
	aRow table printSQLOn: self withParameters: #().
	fields := self arrayBoundFields.
	self space; nextPut: $(.
	GlorpHelper
		do: [:each | self nextPutAll: (self platform nameForColumn: each name)]
		for: fields
		separatedBy: [self nextPut: $,].
	self nextPut: $).
	"Except for inlining the shouldUseGroupWriting call, the following line is the only change from super"
	self nextPutAll: (self outputAddedIdentityColumnValuesIntoTable: identityColumn).
	self nextPutAll: '  VALUES ('.
	GlorpHelper
		do: [:each | (self canBind: (aRow at: each ifAbsent: [nil]) to: each type)
					ifTrue: [self nextPutBindMarkerIn: nil]
					ifFalse: [aRow printValueOfField: each on: self]]
		for: fields
		separatedBy: [self nextPut: $,].
	self nextPut: $).
]

{ #category : #'private-accessing' }
InsertSelectRowsCommand >> selectAddedIdentityColumnValues [
	"This select must be run in the same round trip as the insert that added the values.  It reads the table defined in #declareTableOfIdentitiesStatement, which was populated by the OUTPUT ... expression added in #outputAddedIdentityColumValuesIntoTable:."

	^'; SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue'
]

{ #category : #testing }
InsertSelectRowsCommand >> supportsGroupWriting [
	^true
]
